'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const require$$0 = require('node:module');
const url = require('node:url');
const compilationCache = require('../../../mocks/compilationCache.js');
const portTransport = require('../transform/portTransport.js');
const transform = require('../../../mocks/transform.js');

let loaderChannel;
if (globalThis.__esmLoaderPortPreV20)
  loaderChannel = createPortTransport(globalThis.__esmLoaderPortPreV20);
function registerESMLoader() {
  const { port1, port2 } = new MessageChannel();
  require$$0.register(url.pathToFileURL(require.resolve("../transform/esmLoader")), {
    data: { port: port2 },
    transferList: [port2]
  });
  loaderChannel = createPortTransport(port1);
}
function createPortTransport(port) {
  return new portTransport.PortTransport(port, async (method, params) => {
    if (method === "pushToCompilationCache")
      compilationCache.addToCompilationCache(params.cache);
  });
}
async function configureESMLoader() {
  if (!loaderChannel)
    return;
  await loaderChannel.send("setSingleTSConfig", { tsconfig: transform.singleTSConfig() });
  await loaderChannel.send("addToCompilationCache", { cache: compilationCache.serializeCompilationCache() });
}
async function configureESMLoaderTransformConfig() {
  if (!loaderChannel)
    return;
  await loaderChannel.send("setSingleTSConfig", { tsconfig: transform.singleTSConfig() });
  await loaderChannel.send("setTransformConfig", { config: transform.transformConfig() });
}

exports.configureESMLoader = configureESMLoader;
exports.configureESMLoaderTransformConfig = configureESMLoaderTransformConfig;
exports.registerESMLoader = registerESMLoader;
