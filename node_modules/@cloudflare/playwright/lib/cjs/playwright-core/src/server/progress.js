'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const errors = require('./errors.js');
const assert = require('../utils/isomorphic/assert.js');
require('../utils/isomorphic/selectorParser.js');
require('../utils/isomorphic/builtins.js');
const manualPromise = require('../utils/isomorphic/manualPromise.js');
require('../utils/isomorphic/mimeType.js');
const time = require('../utils/isomorphic/time.js');
require('../utils/isomorphic/urlMatch.js');
require('../../../_virtual/pixelmatch.js');
require('../utilsBundle.js');
require('node:crypto');
require('./utils/debug.js');
require('./utils/debugLogger.js');
require('../../../bundles/fs.js');
require('node:path');
require('../zipBundle.js');
require('./utils/hostPlatform.js');
require('node:http');
require('node:http2');
require('node:https');
require('node:url');
require('./utils/happyEyeballs.js');
require('./utils/nodePlatform.js');
require('node:child_process');
require('node:readline');
require('./utils/profiler.js');
require('./utils/socksProxy.js');
require('node:os');
require('./utils/zones.js');

class ProgressController {
  constructor(metadata, sdkObject) {
    this._forceAbortPromise = new manualPromise.ManualPromise();
    // Cleanups to be run only in the case of abort.
    this._cleanups = [];
    this._logName = "api";
    this._state = "before";
    this._deadline = 0;
    this._timeout = 0;
    this.metadata = metadata;
    this.sdkObject = sdkObject;
    this.instrumentation = sdkObject.instrumentation;
    this._forceAbortPromise.catch((e) => null);
  }
  setLogName(logName) {
    this._logName = logName;
  }
  abort(error) {
    this._forceAbortPromise.reject(error);
  }
  async run(task, timeout) {
    if (timeout) {
      this._timeout = timeout;
      this._deadline = timeout ? time.monotonicTime() + timeout : 0;
    }
    assert.assert(this._state === "before");
    this._state = "running";
    this.sdkObject.attribution.context?._activeProgressControllers.add(this);
    const progress = {
      log: (message) => {
        if (this._state === "running")
          this.metadata.log.push(message);
        this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
      },
      timeUntilDeadline: () => this._deadline ? this._deadline - time.monotonicTime() : 2147483647,
      // 2^31-1 safe setTimeout in Node.
      isRunning: () => this._state === "running",
      cleanupWhenAborted: (cleanup) => {
        if (this._state === "running")
          this._cleanups.push(cleanup);
        else
          runCleanup(cleanup);
      },
      throwIfAborted: () => {
        if (this._state === "aborted")
          throw new AbortedError();
      },
      metadata: this.metadata
    };
    const timeoutError = new errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
    const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());
    try {
      const promise = task(progress);
      const result = await Promise.race([promise, this._forceAbortPromise]);
      this._state = "finished";
      return result;
    } catch (e) {
      this._state = "aborted";
      await Promise.all(this._cleanups.splice(0).map(runCleanup));
      throw e;
    } finally {
      this.sdkObject.attribution.context?._activeProgressControllers.delete(this);
      clearTimeout(timer);
    }
  }
}
async function runCleanup(cleanup) {
  try {
    await cleanup();
  } catch (e) {
  }
}
class AbortedError extends Error {
}

exports.ProgressController = ProgressController;
