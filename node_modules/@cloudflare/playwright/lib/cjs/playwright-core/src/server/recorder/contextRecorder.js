'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const require$$0$3 = require('node:events');
const recorderCollection = require('./recorderCollection.js');
const pollingRecorderSource = require('../../generated/pollingRecorderSource.js');
require('../../utils/isomorphic/selectorParser.js');
const stringUtils = require('../../utils/isomorphic/stringUtils.js');
require('../../utils/isomorphic/builtins.js');
require('../../utils/isomorphic/mimeType.js');
const time = require('../../utils/isomorphic/time.js');
const timeoutRunner = require('../../utils/isomorphic/timeoutRunner.js');
require('../../utils/isomorphic/urlMatch.js');
require('../../../../_virtual/pixelmatch.js');
require('../../utilsBundle.js');
require('node:crypto');
require('../utils/debug.js');
require('../utils/debugLogger.js');
const eventsHelper = require('../utils/eventsHelper.js');
require('../../../../bundles/fs.js');
require('node:path');
require('../../zipBundle.js');
require('../utils/hostPlatform.js');
require('node:http');
require('node:http2');
require('node:https');
require('node:url');
require('../utils/happyEyeballs.js');
require('../utils/nodePlatform.js');
require('node:child_process');
require('node:readline');
require('../utils/profiler.js');
require('../utils/socksProxy.js');
require('node:os');
require('../utils/zones.js');
const browserContext = require('../browserContext.js');
const languages = require('../codegen/languages.js');
const frames = require('../frames.js');
const page = require('../page.js');
const throttledFile = require('./throttledFile.js');
const language = require('../codegen/language.js');

class ContextRecorder extends require$$0$3.EventEmitter {
  constructor(context, params, delegate) {
    super();
    this._pageAliases = /* @__PURE__ */ new Map();
    this._lastPopupOrdinal = 0;
    this._lastDialogOrdinal = -1;
    this._lastDownloadOrdinal = -1;
    this._throttledOutputFile = null;
    this._orderedLanguages = [];
    this._listeners = [];
    this._context = context;
    this._params = params;
    this._delegate = delegate;
    this._recorderSources = [];
    const language$1 = params.language || context.attribution.playwright.options.sdkLanguage;
    this.setOutput(language$1, params.outputFile);
    const languageGeneratorOptions = {
      browserName: context._browser.options.name,
      launchOptions: { headless: false, ...params.launchOptions, tracesDir: void 0 },
      contextOptions: { ...params.contextOptions },
      deviceName: params.device,
      saveStorage: params.saveStorage
    };
    this._collection = new recorderCollection.RecorderCollection(this._pageAliases);
    this._collection.on("change", (actions) => {
      this._recorderSources = [];
      for (const languageGenerator of this._orderedLanguages) {
        const { header, footer, actionTexts, text } = language.generateCode(actions, languageGenerator, languageGeneratorOptions);
        const source = {
          isRecorded: true,
          label: languageGenerator.name,
          group: languageGenerator.groupName,
          id: languageGenerator.id,
          text,
          header,
          footer,
          actions: actionTexts,
          language: languageGenerator.highlighter,
          highlight: []
        };
        source.revealLine = text.split("\n").length - 1;
        this._recorderSources.push(source);
        if (languageGenerator === this._orderedLanguages[0])
          this._throttledOutputFile?.setContent(source.text);
      }
      this.emit(ContextRecorder.Events.Change, {
        sources: this._recorderSources,
        actions
      });
    });
    context.on(browserContext.BrowserContext.Events.BeforeClose, () => {
      this._throttledOutputFile?.flush();
    });
    this._listeners.push(eventsHelper.eventsHelper.addEventListener(process, "exit", () => {
      this._throttledOutputFile?.flush();
    }));
    this.setEnabled(params.mode === "recording");
  }
  static {
    this.Events = {
      Change: "change"
    };
  }
  setOutput(codegenId, outputFile) {
    const languages$1 = languages.languageSet();
    const primaryLanguage = [...languages$1].find((l) => l.id === codegenId);
    if (!primaryLanguage)
      throw new Error(`
===============================
Unsupported language: '${codegenId}'
===============================
`);
    languages$1.delete(primaryLanguage);
    this._orderedLanguages = [primaryLanguage, ...languages$1];
    this._throttledOutputFile = outputFile ? new throttledFile.ThrottledFile(outputFile) : null;
    this._collection?.restart();
  }
  languageName(id) {
    for (const lang of this._orderedLanguages) {
      if (!id || lang.id === id)
        return lang.highlighter;
    }
    return "javascript";
  }
  async install() {
    this._context.on(browserContext.BrowserContext.Events.Page, (page) => this._onPage(page));
    for (const page of this._context.pages())
      this._onPage(page);
    this._context.on(browserContext.BrowserContext.Events.Dialog, (dialog) => this._onDialog(dialog.page()));
    await this._context.exposeBinding(
      "__pw_recorderPerformAction",
      false,
      (source, action) => this._performAction(source.frame, action)
    );
    await this._context.exposeBinding(
      "__pw_recorderRecordAction",
      false,
      (source, action) => this._recordAction(source.frame, action)
    );
    await this._context.extendInjectedScript(pollingRecorderSource.source);
  }
  setEnabled(enabled) {
    this._collection.setEnabled(enabled);
  }
  dispose() {
    eventsHelper.eventsHelper.removeEventListeners(this._listeners);
  }
  async _onPage(page$1) {
    const frame = page$1.mainFrame();
    page$1.on("close", () => {
      this._collection.addRecordedAction({
        frame: this._describeMainFrame(page$1),
        action: {
          name: "closePage",
          signals: []
        },
        startTime: time.monotonicTime()
      });
      this._pageAliases.delete(page$1);
    });
    frame.on(frames.Frame.Events.InternalNavigation, (event) => {
      if (event.isPublic)
        this._onFrameNavigated(frame, page$1);
    });
    page$1.on(page.Page.Events.Download, () => this._onDownload(page$1));
    const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
    const pageAlias = "page" + suffix;
    this._pageAliases.set(page$1, pageAlias);
    if (page$1.opener()) {
      this._onPopup(page$1.opener(), page$1);
    } else {
      this._collection.addRecordedAction({
        frame: this._describeMainFrame(page$1),
        action: {
          name: "openPage",
          url: page$1.mainFrame().url(),
          signals: []
        },
        startTime: time.monotonicTime()
      });
    }
  }
  clearScript() {
    this._collection.restart();
    if (this._params.mode === "recording") {
      for (const page of this._context.pages())
        this._onFrameNavigated(page.mainFrame(), page);
    }
  }
  runTask(task) {
  }
  _describeMainFrame(page) {
    return {
      pageAlias: this._pageAliases.get(page),
      framePath: []
    };
  }
  async _describeFrame(frame) {
    return {
      pageAlias: this._pageAliases.get(frame._page),
      framePath: await generateFrameSelector(frame)
    };
  }
  testIdAttributeName() {
    return this._params.testIdAttributeName || this._context.selectors().testIdAttributeName() || "data-testid";
  }
  async _createActionInContext(frame, action) {
    const frameDescription = await this._describeFrame(frame);
    const actionInContext = {
      frame: frameDescription,
      action,
      description: void 0,
      startTime: time.monotonicTime()
    };
    await this._delegate.rewriteActionInContext?.(this._pageAliases, actionInContext);
    return actionInContext;
  }
  async _performAction(frame, action) {
    await this._collection.performAction(await this._createActionInContext(frame, action));
  }
  async _recordAction(frame, action) {
    this._collection.addRecordedAction(await this._createActionInContext(frame, action));
  }
  _onFrameNavigated(frame, page) {
    const pageAlias = this._pageAliases.get(page);
    this._collection.signal(pageAlias, frame, { name: "navigation", url: frame.url() });
  }
  _onPopup(page, popup) {
    const pageAlias = this._pageAliases.get(page);
    const popupAlias = this._pageAliases.get(popup);
    this._collection.signal(pageAlias, page.mainFrame(), { name: "popup", popupAlias });
  }
  _onDownload(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDownloadOrdinal;
    this._collection.signal(pageAlias, page.mainFrame(), { name: "download", downloadAlias: this._lastDownloadOrdinal ? String(this._lastDownloadOrdinal) : "" });
  }
  _onDialog(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDialogOrdinal;
    this._collection.signal(pageAlias, page.mainFrame(), { name: "dialog", dialogAlias: this._lastDialogOrdinal ? String(this._lastDialogOrdinal) : "" });
  }
}
async function generateFrameSelector(frame) {
  const selectorPromises = [];
  while (frame) {
    const parent = frame.parentFrame();
    if (!parent)
      break;
    selectorPromises.push(generateFrameSelectorInParent(parent, frame));
    frame = parent;
  }
  const result = await Promise.all(selectorPromises);
  return result.reverse();
}
async function generateFrameSelectorInParent(parent, frame) {
  const result = await timeoutRunner.raceAgainstDeadline(async () => {
    try {
      const frameElement = await frame.frameElement();
      if (!frameElement || !parent)
        return;
      const utility = await parent._utilityContext();
      const injected = await utility.injectedScript();
      const selector = await injected.evaluate((injected2, element) => {
        return injected2.generateSelectorSimple(element);
      }, frameElement);
      return selector;
    } catch (e) {
    }
  }, time.monotonicTime() + 2e3);
  if (!result.timedOut && result.result)
    return result.result;
  if (frame.name())
    return `iframe[name=${stringUtils.quoteCSSAttributeValue(frame.name())}]`;
  return `iframe[src=${stringUtils.quoteCSSAttributeValue(frame.url())}]`;
}

exports.ContextRecorder = ContextRecorder;
exports.generateFrameSelector = generateFrameSelector;
