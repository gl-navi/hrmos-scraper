import { TimeoutError } from './errors.js';
import { assert } from '../utils/isomorphic/assert.js';
import '../utils/isomorphic/selectorParser.js';
import '../utils/isomorphic/builtins.js';
import { ManualPromise } from '../utils/isomorphic/manualPromise.js';
import '../utils/isomorphic/mimeType.js';
import { monotonicTime } from '../utils/isomorphic/time.js';
import '../utils/isomorphic/urlMatch.js';
import '../../../_virtual/pixelmatch.js';
import '../utilsBundle.js';
import 'node:crypto';
import './utils/debug.js';
import './utils/debugLogger.js';
import '../../../bundles/fs.js';
import 'node:path';
import '../zipBundle.js';
import './utils/hostPlatform.js';
import 'node:http';
import 'node:http2';
import 'node:https';
import 'node:url';
import './utils/happyEyeballs.js';
import './utils/nodePlatform.js';
import 'node:child_process';
import 'node:readline';
import './utils/profiler.js';
import './utils/socksProxy.js';
import 'node:os';
import './utils/zones.js';

class ProgressController {
  constructor(metadata, sdkObject) {
    this._forceAbortPromise = new ManualPromise();
    // Cleanups to be run only in the case of abort.
    this._cleanups = [];
    this._logName = "api";
    this._state = "before";
    this._deadline = 0;
    this._timeout = 0;
    this.metadata = metadata;
    this.sdkObject = sdkObject;
    this.instrumentation = sdkObject.instrumentation;
    this._forceAbortPromise.catch((e) => null);
  }
  setLogName(logName) {
    this._logName = logName;
  }
  abort(error) {
    this._forceAbortPromise.reject(error);
  }
  async run(task, timeout) {
    if (timeout) {
      this._timeout = timeout;
      this._deadline = timeout ? monotonicTime() + timeout : 0;
    }
    assert(this._state === "before");
    this._state = "running";
    this.sdkObject.attribution.context?._activeProgressControllers.add(this);
    const progress = {
      log: (message) => {
        if (this._state === "running")
          this.metadata.log.push(message);
        this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
      },
      timeUntilDeadline: () => this._deadline ? this._deadline - monotonicTime() : 2147483647,
      // 2^31-1 safe setTimeout in Node.
      isRunning: () => this._state === "running",
      cleanupWhenAborted: (cleanup) => {
        if (this._state === "running")
          this._cleanups.push(cleanup);
        else
          runCleanup(cleanup);
      },
      throwIfAborted: () => {
        if (this._state === "aborted")
          throw new AbortedError();
      },
      metadata: this.metadata
    };
    const timeoutError = new TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
    const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());
    try {
      const promise = task(progress);
      const result = await Promise.race([promise, this._forceAbortPromise]);
      this._state = "finished";
      return result;
    } catch (e) {
      this._state = "aborted";
      await Promise.all(this._cleanups.splice(0).map(runCleanup));
      throw e;
    } finally {
      this.sdkObject.attribution.context?._activeProgressControllers.delete(this);
      clearTimeout(timer);
    }
  }
}
async function runCleanup(cleanup) {
  try {
    await cleanup();
  } catch (e) {
  }
}
class AbortedError extends Error {
}

export { ProgressController };
