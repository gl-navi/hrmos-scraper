import fs from '../../../bundles/fs.js';
import path from 'node:path';
import { TimeoutSettings } from './timeoutSettings.js';
import { createGuid } from './utils/crypto.js';
import { debugMode } from './utils/debug.js';
import { Clock } from './clock.js';
import { Debugger } from './debugger.js';
import { BrowserContextAPIRequestContext } from './fetch.js';
import { mkdirIfNeeded } from './utils/fileUtils.js';
import { HarRecorder } from './har/harRecorder.js';
import { helper } from './helper.js';
import { SdkObject, serverSideCallMetadata } from './instrumentation.js';
import { builtins } from '../utils/isomorphic/builtins.js';
import { source } from '../utils/isomorphic/utilityScriptSerializers.js';
import { mergeHeaders, singleHeader } from './network.js';
import { PageBinding, InitScript, Page } from './page.js';
import { Recorder } from './recorder.js';
import { RecorderApp } from './recorder/recorderApp.js';
import { collect, restore } from './storageScript.js';
import { Tracing } from './trace/recorder/tracing.js';

class BrowserContext extends SdkObject {
  constructor(browser, options, browserContextId) {
    super(browser, "browser-context");
    this._timeoutSettings = new TimeoutSettings();
    this._pageBindings = /* @__PURE__ */ new Map();
    this._activeProgressControllers = /* @__PURE__ */ new Set();
    this._closedStatus = "open";
    this._permissions = /* @__PURE__ */ new Map();
    this._downloads = /* @__PURE__ */ new Set();
    this._origins = /* @__PURE__ */ new Set();
    this._harRecorders = /* @__PURE__ */ new Map();
    this._tempDirs = [];
    this._settingStorageState = false;
    this.initScripts = [];
    this._routesInFlight = /* @__PURE__ */ new Set();
    this.attribution.context = this;
    this._browser = browser;
    this._options = options;
    this._browserContextId = browserContextId;
    this._isPersistentContext = !browserContextId;
    this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
    this.fetchRequest = new BrowserContextAPIRequestContext(this);
    if (this._options.recordHar)
      this._harRecorders.set("", new HarRecorder(this, null, this._options.recordHar));
    this.tracing = new Tracing(this, browser.options.tracesDir);
    this.clock = new Clock(this);
  }
  static {
    this.Events = {
      Console: "console",
      Close: "close",
      Dialog: "dialog",
      Page: "page",
      // Can't use just 'error' due to node.js special treatment of error events.
      // @see https://nodejs.org/api/events.html#events_error_events
      PageError: "pageerror",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      RequestAborted: "requestaborted",
      RequestFulfilled: "requestfulfilled",
      RequestContinued: "requestcontinued",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
  }
  isPersistentContext() {
    return this._isPersistentContext;
  }
  setSelectors(selectors) {
    this._selectors = selectors;
  }
  selectors() {
    return this._selectors || this.attribution.playwright.selectors;
  }
  async _initialize() {
    if (this.attribution.playwright.options.isInternalPlaywright)
      return;
    this._debugger = new Debugger(this);
    if (debugMode() === "inspector")
      await Recorder.show(this, RecorderApp.factory(this), { pauseOnNextStatement: true });
    if (this._debugger.isPaused())
      Recorder.showInspectorNoReply(this, RecorderApp.factory(this));
    this._debugger.on(Debugger.Events.PausedStateChanged, () => {
      if (this._debugger.isPaused())
        Recorder.showInspectorNoReply(this, RecorderApp.factory(this));
    });
    if (debugMode() === "console")
      await this.extendInjectedScript("function Console(injectedScript) { injectedScript.consoleApi.install(); }");
    if (this._options.serviceWorkers === "block")
      await this.addInitScript(`
if (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };
`);
    if (this._options.permissions)
      await this.grantPermissions(this._options.permissions);
  }
  debugger() {
    return this._debugger;
  }
  async _ensureVideosPath() {
    if (this._options.recordVideo)
      await mkdirIfNeeded(path.join(this._options.recordVideo.dir, "dummy"));
  }
  canResetForReuse() {
    if (this._closedStatus !== "open")
      return false;
    return true;
  }
  async stopPendingOperations(reason) {
    for (const controller of this._activeProgressControllers)
      controller.abort(new Error(reason));
    await new Promise((f) => setTimeout(f, 0));
  }
  static reusableContextHash(params) {
    const paramsCopy = { ...params };
    for (const k of Object.keys(paramsCopy)) {
      const key = k;
      if (paramsCopy[key] === defaultNewContextParamValues[key])
        delete paramsCopy[key];
    }
    for (const key of paramsThatAllowContextReuse)
      delete paramsCopy[key];
    return JSON.stringify(paramsCopy);
  }
  async resetForReuse(metadata, params) {
    this.setDefaultNavigationTimeout(void 0);
    this.setDefaultTimeout(void 0);
    this.tracing.resetForReuse();
    if (params) {
      for (const key of paramsThatAllowContextReuse)
        this._options[key] = params[key];
    }
    await this._cancelAllRoutesInFlight();
    let page = this.pages()[0];
    const [, ...otherPages] = this.pages();
    for (const p of otherPages)
      await p.close(metadata);
    if (page && page.hasCrashed()) {
      await page.close(metadata);
      page = void 0;
    }
    page?._frameManager.setCloseAllOpeningDialogs(true);
    await page?._frameManager.closeOpenDialogs();
    await page?.mainFrame().goto(metadata, "about:blank", { timeout: 0 });
    page?._frameManager.setCloseAllOpeningDialogs(false);
    await this._resetStorage();
    await this._removeExposedBindings();
    await this._removeInitScripts();
    this.clock.markAsUninstalled();
    if (this._options.permissions)
      await this.grantPermissions(this._options.permissions);
    else
      await this.clearPermissions();
    await this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []);
    await this.setGeolocation(this._options.geolocation);
    await this.setOffline(!!this._options.offline);
    await this.setUserAgent(this._options.userAgent);
    await this.clearCache();
    await this._resetCookies();
    await page?.resetForReuse(metadata);
  }
  _browserClosed() {
    for (const page of this.pages())
      page._didClose();
    this._didCloseInternal();
  }
  _didCloseInternal() {
    if (this._closedStatus === "closed") {
      return;
    }
    this._clientCertificatesProxy?.close().catch(() => {
    });
    this.tracing.abort();
    if (this._isPersistentContext)
      this.onClosePersistent();
    this._closePromiseFulfill(new Error("Context closed"));
    this.emit(BrowserContext.Events.Close);
  }
  pages() {
    return this.possiblyUninitializedPages().filter((page) => page.initializedOrUndefined());
  }
  async cookies(urls = []) {
    if (urls && !Array.isArray(urls))
      urls = [urls];
    return await this.doGetCookies(urls);
  }
  async clearCookies(options) {
    const currentCookies = await this.cookies();
    await this.doClearCookies();
    const matches = (cookie, prop, value) => {
      if (!value)
        return true;
      if (value instanceof RegExp) {
        value.lastIndex = 0;
        return value.test(cookie[prop]);
      }
      return cookie[prop] === value;
    };
    const cookiesToReadd = currentCookies.filter((cookie) => {
      return !matches(cookie, "name", options.name) || !matches(cookie, "domain", options.domain) || !matches(cookie, "path", options.path);
    });
    await this.addCookies(cookiesToReadd);
  }
  setHTTPCredentials(httpCredentials) {
    return this.doSetHTTPCredentials(httpCredentials);
  }
  hasBinding(name) {
    return this._pageBindings.has(name);
  }
  async exposeBinding(name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered`);
    for (const page of this.pages()) {
      if (page.getBinding(name))
        throw new Error(`Function "${name}" has been already registered in one of the pages`);
    }
    const binding = new PageBinding(name, playwrightBinding, needsHandle);
    this._pageBindings.set(name, binding);
    await this.doAddInitScript(binding.initScript);
    const frames = this.pages().map((page) => page.frames()).flat();
    await Promise.all(frames.map((frame) => frame.evaluateExpression(binding.initScript.source).catch((e) => {
    })));
  }
  async _removeExposedBindings() {
    for (const [key, binding] of this._pageBindings) {
      if (!binding.internal)
        this._pageBindings.delete(key);
    }
  }
  async grantPermissions(permissions, origin) {
    let resolvedOrigin = "*";
    if (origin) {
      const url = new URL(origin);
      resolvedOrigin = url.origin;
    }
    const existing = new Set(this._permissions.get(resolvedOrigin) || []);
    permissions.forEach((p) => existing.add(p));
    const list = [...existing.values()];
    this._permissions.set(resolvedOrigin, list);
    await this.doGrantPermissions(resolvedOrigin, list);
  }
  async clearPermissions() {
    this._permissions.clear();
    await this.doClearPermissions();
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async _loadDefaultContextAsIs(progress) {
    if (!this.possiblyUninitializedPages().length) {
      const waitForEvent = helper.waitForEvent(progress, this, BrowserContext.Events.Page);
      progress.cleanupWhenAborted(() => waitForEvent.dispose);
      await Promise.race([waitForEvent.promise, this._closePromise]);
    }
    const page = this.possiblyUninitializedPages()[0];
    if (!page)
      return;
    const pageOrError = await page.waitForInitializedOrError();
    if (pageOrError instanceof Error)
      throw pageOrError;
    await page.mainFrame()._waitForLoadState(progress, "load");
    return page;
  }
  async _loadDefaultContext(progress) {
    const defaultPage = await this._loadDefaultContextAsIs(progress);
    if (!defaultPage)
      return;
    const browserName = this._browser.options.name;
    if (this._options.isMobile && browserName === "chromium" || this._options.locale && browserName === "webkit") {
      await this.newPage(progress.metadata);
      await defaultPage.close(progress.metadata);
    }
  }
  _authenticateProxyViaHeader() {
    const proxy = this._options.proxy || this._browser.options.proxy || { username: void 0, password: void 0 };
    const { username, password } = proxy;
    if (username) {
      this._options.httpCredentials = { username, password };
      const token = Buffer.from(`${username}:${password}`).toString("base64");
      this._options.extraHTTPHeaders = mergeHeaders([
        this._options.extraHTTPHeaders,
        singleHeader("Proxy-Authorization", `Basic ${token}`)
      ]);
    }
  }
  _authenticateProxyViaCredentials() {
    const proxy = this._options.proxy || this._browser.options.proxy;
    if (!proxy)
      return;
    const { username, password } = proxy;
    if (username)
      this._options.httpCredentials = { username, password: password || "" };
  }
  async addInitScript(source, name) {
    const initScript = new InitScript(source, false, name);
    this.initScripts.push(initScript);
    await this.doAddInitScript(initScript);
  }
  async _removeInitScripts() {
    this.initScripts = this.initScripts.filter((script) => script.internal);
    await this.doRemoveNonInternalInitScripts();
  }
  async setRequestInterceptor(handler) {
    this._requestInterceptor = handler;
    await this.doUpdateRequestInterception();
  }
  isClosingOrClosed() {
    return this._closedStatus !== "open";
  }
  async _deleteAllDownloads() {
    await Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
  }
  async _deleteAllTempDirs() {
    await Promise.all(this._tempDirs.map(async (dir) => await fs.promises.unlink(dir).catch((e) => {
    })));
  }
  setCustomCloseHandler(handler) {
    this._customCloseHandler = handler;
  }
  async close(options) {
    if (this._closedStatus === "open") {
      if (options.reason)
        this._closeReason = options.reason;
      this.emit(BrowserContext.Events.BeforeClose);
      this._closedStatus = "closing";
      for (const harRecorder of this._harRecorders.values())
        await harRecorder.flush();
      await this.tracing.flush();
      const promises = [];
      for (const { context, artifact } of this._browser._idToVideo.values()) {
        if (context === this)
          promises.push(artifact.finishedPromise());
      }
      if (this._customCloseHandler) {
        await this._customCloseHandler();
      } else {
        await this.doClose(options.reason);
      }
      promises.push(this._deleteAllDownloads());
      promises.push(this._deleteAllTempDirs());
      await Promise.all(promises);
      if (!this._customCloseHandler)
        this._didCloseInternal();
    }
    await this._closePromise;
  }
  async newPage(metadata) {
    const page = await this.doCreateNewPage();
    if (metadata.isServerSide)
      page.markAsServerSideOnly();
    const pageOrError = await page.waitForInitializedOrError();
    if (pageOrError instanceof Page) {
      if (pageOrError.isClosed())
        throw new Error("Page has been closed.");
      return pageOrError;
    }
    throw pageOrError;
  }
  addVisitedOrigin(origin) {
    this._origins.add(origin);
  }
  async storageState(indexedDB = false) {
    const result = {
      cookies: await this.cookies(),
      origins: []
    };
    const originsToSave = new Set(this._origins);
    let collectScript = `(${collect})(${source}, (${builtins})(), ${this._browser.options.name === "firefox"}, ${indexedDB})`;
    collectScript = `((__name => (${collectScript}))(t => t))`;
    for (const page of this.pages()) {
      const origin = page.mainFrame().origin();
      if (!origin || !originsToSave.has(origin))
        continue;
      try {
        const storage = await page.mainFrame().nonStallingEvaluateInExistingContext(collectScript, "utility");
        if (storage.localStorage.length || storage.indexedDB?.length)
          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
        originsToSave.delete(origin);
      } catch {
      }
    }
    if (originsToSave.size) {
      const internalMetadata = serverSideCallMetadata();
      const page = await this.newPage(internalMetadata);
      await page._setServerRequestInterceptor((handler) => {
        handler.fulfill({ body: "<html></html>" }).catch(() => {
        });
        return true;
      });
      for (const origin of originsToSave) {
        const frame = page.mainFrame();
        await frame.goto(internalMetadata, origin);
        const storage = await frame.evaluateExpression(collectScript, { world: "utility" });
        if (storage.localStorage.length || storage.indexedDB?.length)
          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
      }
      await page.close(internalMetadata);
    }
    return result;
  }
  async _resetStorage() {
    const oldOrigins = this._origins;
    const newOrigins = new Map(this._options.storageState?.origins?.map((p) => [p.origin, p]) || []);
    if (!oldOrigins.size && !newOrigins.size)
      return;
    let page = this.pages()[0];
    const internalMetadata = serverSideCallMetadata();
    page = page || await this.newPage({
      ...internalMetadata,
      // Do not mark this page as internal, because we will leave it for later reuse
      // as a user-visible page.
      isServerSide: false
    });
    await page._setServerRequestInterceptor((handler) => {
      handler.fulfill({ body: "<html></html>" }).catch(() => {
      });
      return true;
    });
    for (const origin of /* @__PURE__ */ new Set([...oldOrigins, ...newOrigins.keys()])) {
      const frame = page.mainFrame();
      await frame.goto(internalMetadata, origin);
      await frame.resetStorageForCurrentOriginBestEffort(newOrigins.get(origin));
    }
    await page._setServerRequestInterceptor(void 0);
    this._origins = /* @__PURE__ */ new Set([...newOrigins.keys()]);
  }
  async _resetCookies() {
    await this.doClearCookies();
    if (this._options.storageState?.cookies)
      await this.addCookies(this._options.storageState?.cookies);
  }
  isSettingStorageState() {
    return this._settingStorageState;
  }
  async setStorageState(metadata, state) {
    this._settingStorageState = true;
    try {
      if (state.cookies)
        await this.addCookies(state.cookies);
      if (state.origins && state.origins.length) {
        const internalMetadata = serverSideCallMetadata();
        const page = await this.newPage(internalMetadata);
        await page._setServerRequestInterceptor((handler) => {
          handler.fulfill({ body: "<html></html>" }).catch(() => {
          });
          return true;
        });
        for (const originState of state.origins) {
          const frame = page.mainFrame();
          await frame.goto(metadata, originState.origin);
          const restoreScript = `((__name => (${restore}))(t => t))`;
          const utilityScriptSerializersScript = `((__name => (${source}))(t => t))`;
          const builtinsScript = `((__name => (${builtins}))(t => t))`;
          await frame.evaluateExpression(`(${restoreScript})(${utilityScriptSerializersScript}, (${builtinsScript})(), ${JSON.stringify(originState)})`, { world: "utility" });
        }
        await page.close(internalMetadata);
      }
    } finally {
      this._settingStorageState = false;
    }
  }
  async extendInjectedScript(source, arg) {
    const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
    });
    const installInPage = (page) => {
      page.on(Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
      return Promise.all(page.frames().map(installInFrame));
    };
    this.on(BrowserContext.Events.Page, installInPage);
    return Promise.all(this.pages().map(installInPage));
  }
  async safeNonStallingEvaluateInAllFrames(expression, world, options = {}) {
    await Promise.all(this.pages().map((page) => page.safeNonStallingEvaluateInAllFrames(expression, world, options)));
  }
  async _harStart(page, options) {
    const harId = createGuid();
    this._harRecorders.set(harId, new HarRecorder(this, page, options));
    return harId;
  }
  async _harExport(harId) {
    const recorder = this._harRecorders.get(harId || "");
    return recorder.export();
  }
  addRouteInFlight(route) {
    this._routesInFlight.add(route);
  }
  removeRouteInFlight(route) {
    this._routesInFlight.delete(route);
  }
  async _cancelAllRoutesInFlight() {
    await Promise.all([...this._routesInFlight].map((r) => r.abort())).catch(() => {
    });
    this._routesInFlight.clear();
  }
}
function assertBrowserContextIsNotOwned(context) {
  for (const page of context.pages()) {
    if (page._ownedContext)
      throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
  }
}
function validateBrowserContextOptions(options, browserOptions) {
  if (options.noDefaultViewport && options.deviceScaleFactor !== void 0)
    throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
  if (options.noDefaultViewport && !!options.isMobile)
    throw new Error(`"isMobile" option is not supported with null "viewport"`);
  if (options.acceptDownloads === void 0 && browserOptions.name !== "electron")
    options.acceptDownloads = "accept";
  else if (options.acceptDownloads === void 0 && browserOptions.name === "electron")
    options.acceptDownloads = "internal-browser-default";
  if (!options.viewport && !options.noDefaultViewport)
    options.viewport = { width: 1280, height: 720 };
  if (options.recordVideo) {
    if (!options.recordVideo.size) {
      if (options.noDefaultViewport) {
        options.recordVideo.size = { width: 800, height: 600 };
      } else {
        const size = options.viewport;
        const scale = Math.min(1, 800 / Math.max(size.width, size.height));
        options.recordVideo.size = {
          width: Math.floor(size.width * scale),
          height: Math.floor(size.height * scale)
        };
      }
    }
    options.recordVideo.size.width &= -2;
    options.recordVideo.size.height &= -2;
  }
  if (options.proxy)
    options.proxy = normalizeProxySettings(options.proxy);
  verifyGeolocation(options.geolocation);
}
function verifyGeolocation(geolocation) {
  if (!geolocation)
    return;
  geolocation.accuracy = geolocation.accuracy || 0;
  const { longitude, latitude, accuracy } = geolocation;
  if (longitude < -180 || longitude > 180)
    throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
  if (latitude < -90 || latitude > 90)
    throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
  if (accuracy < 0)
    throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
}
function verifyClientCertificates(clientCertificates) {
  if (!clientCertificates)
    return;
  for (const cert of clientCertificates) {
    if (!cert.origin)
      throw new Error(`clientCertificates.origin is required`);
    if (!cert.cert && !cert.key && !cert.passphrase && !cert.pfx)
      throw new Error("None of cert, key, passphrase or pfx is specified");
    if (cert.cert && !cert.key)
      throw new Error("cert is specified without key");
    if (!cert.cert && cert.key)
      throw new Error("key is specified without cert");
    if (cert.pfx && (cert.cert || cert.key))
      throw new Error("pfx is specified together with cert, key or passphrase");
  }
}
function normalizeProxySettings(proxy) {
  let { server, bypass } = proxy;
  let url;
  try {
    url = new URL(server);
    if (!url.host || !url.protocol)
      url = new URL("http://" + server);
  } catch (e) {
    url = new URL("http://" + server);
  }
  if (url.protocol === "socks4:" && (proxy.username || proxy.password))
    throw new Error(`Socks4 proxy protocol does not support authentication`);
  if (url.protocol === "socks5:" && (proxy.username || proxy.password))
    throw new Error(`Browser does not support socks5 proxy authentication`);
  server = url.protocol + "//" + url.host;
  if (bypass)
    bypass = bypass.split(",").map((t) => t.trim()).join(",");
  return { ...proxy, server, bypass };
}
const paramsThatAllowContextReuse = [
  "colorScheme",
  "forcedColors",
  "reducedMotion",
  "contrast",
  "screen",
  "userAgent",
  "viewport"
];
const defaultNewContextParamValues = {
  noDefaultViewport: false,
  ignoreHTTPSErrors: false,
  javaScriptEnabled: true,
  bypassCSP: false,
  offline: false,
  isMobile: false,
  hasTouch: false,
  acceptDownloads: "accept",
  strictSelectors: false,
  serviceWorkers: "allow",
  locale: "en-US"
};

export { BrowserContext, assertBrowserContextIsNotOwned, normalizeProxySettings, validateBrowserContextOptions, verifyClientCertificates, verifyGeolocation };
