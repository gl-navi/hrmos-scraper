'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

async function waitForCompletion(context, page, callback) {
  const requests = /* @__PURE__ */ new Set();
  let frameNavigated = false;
  let waitCallback = () => {
  };
  const waitBarrier = new Promise((f) => {
    waitCallback = f;
  });
  const requestListener = (request) => requests.add(request);
  const requestFinishedListener = (request) => {
    requests.delete(request);
    if (!requests.size)
      waitCallback();
  };
  const frameNavigateListener = (frame) => {
    if (frame.parentFrame())
      return;
    frameNavigated = true;
    dispose();
    clearTimeout(timeout);
    void frame.waitForLoadState("load").then(() => {
      waitCallback();
    });
  };
  const onTimeout = () => {
    dispose();
    waitCallback();
  };
  page.on("request", requestListener);
  page.on("requestfinished", requestFinishedListener);
  page.on("framenavigated", frameNavigateListener);
  const timeout = setTimeout(onTimeout, 1e4);
  const dispose = () => {
    page.off("request", requestListener);
    page.off("requestfinished", requestFinishedListener);
    page.off("framenavigated", frameNavigateListener);
    clearTimeout(timeout);
  };
  try {
    const result = await callback();
    if (!requests.size && !frameNavigated)
      waitCallback();
    await waitBarrier;
    await context.waitForTimeout(1e3);
    return result;
  } finally {
    dispose();
  }
}
function sanitizeForFilePath(s) {
  return s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, "-");
}

exports.sanitizeForFilePath = sanitizeForFilePath;
exports.waitForCompletion = waitForCompletion;
