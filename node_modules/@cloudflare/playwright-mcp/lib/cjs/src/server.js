'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const index_js = require('@modelcontextprotocol/sdk/server/index.js');
const types_js = require('@modelcontextprotocol/sdk/types.js');
const zodToJsonSchema = require('zod-to-json-schema');
const context = require('./context.js');

function createServerWithTools(options) {
  const { name, version, tools, resources } = options;
  const context$1 = new context.Context(tools, options);
  const server = new index_js.Server({ name, version }, {
    capabilities: {
      tools: {},
      resources: {}
    }
  });
  server.setRequestHandler(types_js.ListToolsRequestSchema, async () => {
    return {
      tools: tools.map((tool) => ({
        name: tool.schema.name,
        description: tool.schema.description,
        inputSchema: zodToJsonSchema.zodToJsonSchema(tool.schema.inputSchema)
      }))
    };
  });
  server.setRequestHandler(types_js.ListResourcesRequestSchema, async () => {
    return { resources: resources.map((resource) => resource.schema) };
  });
  server.setRequestHandler(types_js.CallToolRequestSchema, async (request) => {
    const tool = tools.find((tool2) => tool2.schema.name === request.params.name);
    if (!tool) {
      return {
        content: [{ type: "text", text: `Tool "${request.params.name}" not found` }],
        isError: true
      };
    }
    const modalStates = context$1.modalStates().map((state) => state.type);
    if (tool.clearsModalState && !modalStates.includes(tool.clearsModalState) || !tool.clearsModalState && modalStates.length) {
      const text = [
        `Tool "${request.params.name}" does not handle the modal state.`,
        ...context$1.modalStatesMarkdown()
      ].join("\n");
      return {
        content: [{ type: "text", text }],
        isError: true
      };
    }
    try {
      return await context$1.run(tool, request.params.arguments);
    } catch (error) {
      return {
        content: [{ type: "text", text: String(error) }],
        isError: true
      };
    }
  });
  server.setRequestHandler(types_js.ReadResourceRequestSchema, async (request) => {
    const resource = resources.find((resource2) => resource2.schema.uri === request.params.uri);
    if (!resource)
      return { contents: [] };
    const contents = await resource.read(context$1, request.params.uri);
    return { contents };
  });
  const oldClose = server.close.bind(server);
  server.close = async () => {
    await oldClose();
    await context$1.close();
  };
  return server;
}

exports.createServerWithTools = createServerWithTools;
